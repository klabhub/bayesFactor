function [fe,re,loglike] = bootstrap(m,varargin)
% For most datasets, the residuals of a linear mixed model are unlikely to
% be normally distributed. This means the assumptions of the LME are
% violated. In practice, however, this does not affect the fixed effect
% estimates greatly:
% See  Schielzeth, H. et al. Robustness of linear mixed-effects models to violations of 
% distributional assumptions. Methods Ecol. Evol. 11, 1141â€“1152 (2020).
% 
% This function provides two methods ('mode') to assess the
% robustness of the fixed effects. 
%
% *** Bootstrap resampling subjects.('RESAMPLE' mode) ***
% This mode resamples the data (with replacement) at the subject level
% (assuming that the subject is included as a grouping variable).
% 
% In each bootstrap set, we take the data from a random subset of the subjects
% to create a resampled data set with the same number of data rows and
% subjects. Each of these subjects is assigned a new
% unique name (otherwise the number of random effects could change in each iteration)
% ,then the LME is fit using the same settings as the original
% model (m). 
%

% *** Simulated responses plus noise ('FITPLUSNOISE' mode) ***
% In this mode, we assume that the fitted fixed and random effects in the
% model are the true parameters and then generate surrogate datasets based
% on these parameters plus noise. The noise is generated from a probability
% distribution that is estimated from the residuals of the model (using a
% non-parametric kernel density method (see 'kernel' option in fitdist)).
% In other words, this asks whether the LME analysis would find the correct
% linear model if the responses were generated by y=X*beta +noise where
% beta are the estimated fixed and random effects, and noise is the
% estimated (non-normal) distribution of residuals. If the fixedEffects
% returned by this mode are tightly clustered around the estimated fixed
% effects then we can conclude that the non-normal residuals did not affect
% the estimation greatly.
% 
% By default, the noise distribution is assumed to be the same for
% all response values (i.e. homoscedasticity). By specifying a number larger than 
% 1 for the 'nrHeteroBins' parameter, this function will divide the
% response data into that many bins (with an approximately equal number of
% sample) and estimate a noise distribution for each bin. The noise for the pseudo-response
% is then generated according to the bin that contains that response. 
% In other words, this simulates the heteroscedasiticy found in the data and thereby 
% assess whether this violation of the LME assumptions could affect the outcome.  
% 
% Note that if you pick a large number of bins to 
% do this, the estimate of the noise in each bin will be worse (fewer
% samples). It is probably best to first inspect the residuals
% (plotResiduals(m,'fitted') and based on that plot determine how many
%  bins are needed to divide the residuals into groups with different
%  distributions. With 'graph' set to true, the last subplot shows the
%  actual residuals in each bin (bar histogram) , plus the kernel estimate (line). 
% If these fits look bad (or if all look similar) then you probably have
% too many heteroBins.
%
%%%%%%%%
% INPUT
% m - The  (generalized) linear mixed model
% 'subjectVariable' - Specify which variable should be resampled. ['subject']
% 'nrMonteCarlo' - Number of sets to compute [100]
% 'nrWorkers' - How many parallel workers to use [0]
% 'graph' - Show an graphical output [false]
% 'mode' - 'RESAMPLE' or 'FITPLUSNOISE' 
% 'alpha' - Significance level for confidence intervals [0.05]  (i.e. a 95%
% confidence intervals)
%  'nrHeteroBins' - Number of bins used to simulate heteroscedasticity [1].
% OUTPUT
% fe  - Struct with 
%           .mean - mean of bootstrap sets
%           .std - standard deviation of bootstrap sets/
%           .ci  - confidence intervals based on the bootstrap sets.
%           .all  - the full bootstrap set.
%           .significanceMatch shows whether significance reported in the original model
%           matches the outcome of a significance test using the bootstrapped sets (i.e. based on the bootstrap CI)
%           The values in this vector can be -1 (Fixed effects with non-significant values in the original model)
%           1 (FE that are significant according to the original model estimate as well as the bootstrap
%           estimate) or 0 (significant FE that are
%           non-significant according to the bootstrap estimate)
%           The idea here is that one would only draw conclusions about the
%           FE that are significant in the original model, and therefore we
%           only have to flag (with 0) those for which the boostrap estimates
%           does not agree (suggesting that the non-normality of the noise
%           affects the estimate too much).
% 
% randomEffects - Struct with mean, stdev, and confidence interval for the
%                   random effects. The .all field contains the full bootstrap set.
%
% loglike  - The log likelihood for each boostrap set.
% BK -  Nov 2022.

p=inputParser;
p.addRequired('lm',@(x) (isa(x,'GeneralizedLinearMixedModel') || isa(x,'LinearMixedModel'))); % The original LME
p.addParameter('subjectVariable','subject',@ischar);  % Indicate which (grouping) variable should be used for resampling
p.addParameter('nrMonteCarlo',100,@isnumeric); % Number sets.
p.addParameter('nrWorkers',0,@isnumeric); % Number of parallel workers. By default no parfor
p.addParameter('mode','RESAMPLE',@(x) (ischar(x) && ismember(x,{'RESAMPLE','FITPLUSNOISE'}))); % Mode; see aove
p.addParameter('alpha',0.05,@isnumeric); % Significnace level for CI
p.addParameter('graph',false,@islogical); % Show graphs
p.addParameter('nrHeteroBins',1);
p.parse(m,varargin{:});

if any(m.ObservationInfo.Excluded)
    error('This model has excluded some observations by using the ''Exclude'' argument to fitglme/fitlme. Please remove the data from the data table instead, then call fit without ''Exclude'' and then pass to this function');
end

% Create local variables to reduce parfor broadcasting
nrHeteroBins      = p.Results.nrHeteroBins;
mode            = p.Results.mode;
nrMonteCarlo    = p.Results.nrMonteCarlo;
nrWorkers       = p.Results.nrWorkers;
subjectVariable = p.Results.subjectVariable;
T               = m.Variables;
subjects        = T.(subjectVariable);
uSubjects       = unique(subjects);
nrSubjects      = numel(uSubjects);
dummyVarCoding = lm.dummyVarCoding(m);
%#ok<*PFBNS>   % Suppress broadcasting message.


% Preallocate
nrFixedEffects  = size(m.fixedEffects,1);
nrRandomEffects =  size(m.randomEffects,1);
fixedEffects    = nan(nrFixedEffects,nrMonteCarlo);
randomEffects   = nan(nrRandomEffects,nrMonteCarlo);
loglike         = nan(1,nrMonteCarlo); % Log likelihood.

% Use a dataqueue to show progress updates
dataQueue = parallel.pool.DataQueue;
hWaithBar = waitbar(0,['Bootstrapping ' m.Formula.char ]);
cntr =0;
nrTotal = nrMonteCarlo;
    function updateWaitBar(~)
        cntr=  cntr+1;
        waitbar(cntr/nrTotal,hWaithBar);
    end
afterEach(dataQueue,@updateWaitBar);

if strcmpi(mode,'FITPLUSNOISE')
    response = predict(m);    
    % To handle heteroscedasiticity
    % Determine bins with the same number of samples per bin
    bins = prctile(response,linspace(0,100,nrHeteroBins+1));
    % Associate response with the bin
    [~,~,responseGroupingIx]  = histcounts(response,bins);
    % Kernel density estimate per bin
    noiseDistribution  = fitdist(m.residuals,'kernel','kernel','epanechnikov','By',responseGroupingIx);    
else
    % Not usedm but need to be defined for parfor
    responseGroupingIx=[];
    noiseDistribution  =[] ; 
    response =[];
end

parfor (i=1:nrMonteCarlo ,nrWorkers )
% for i=1:nrMonteCarlo % Use this when debugging
    switch upper(mode)
        case 'RESAMPLE'
            % Select random subset of subjects with resampling and same total
            % number.
            subjectsToUse = uSubjects(randi(nrSubjects,[nrSubjects 1]));
            subjectsSoFar = 0;
            % Now create a new data table from the data for this subject, but
            % assign a new ID to each of the resampled subjects
            setT = table;
            for sub = subjectsToUse
                subjectsSoFar = subjectsSoFar +1; % Used to generate new IDs
                keep = ismember(subjects,sub);
                resampledSubject= m.Variables(keep,:);
                % Assign a new ID to each subject
                resampledSubject.(subjectVariable) = repmat(categorical(subjectsSoFar),[sum(keep) 1]);
                setT = [setT; resampledSubject];
            end
        case 'FITPLUSNOISE'
            % For each set, simulate the response as the (linear) prediction of the
            % estimate plus noise based on the kernel estimate of the
            % residuals.
            setT = T;
            for b=1:nrHeteroBins
                thisGroup = responseGroupingIx==b;
                setT.(m.ResponseName)(thisGroup) = response(thisGroup)+ random(noiseDistribution{b},[sum(thisGroup) 1]);
            end
        otherwise
            % Cannot get here, but without it parfor parsing gets confused
            % about setT.
            setT = [];
            erorr('???')
    end   
    % Estimate model parameters based on the current set.
    if isa(m,'GeneralizedLinearMixedModel')
        thisM =fitglme(setT,char(m.Formula),'Distribution',m.Distribution,'link',m.Link,'DummyVarCoding',dummyVarCoding);
    else
        thisM =fitlme(setT,char(m.Formula),'DummyVarCoding',dummyVarCoding);
    end

    % Store the fixed and random effects
    fixedEffects(:,i) = thisM.fixedEffects;
    randomEffects(:,i) = thisM.randomEffects;
    loglike(i) = thisM.ModelCriterion.LogLikelihood;
    % Update the data queue
    send(dataQueue,i);
end
close(hWaithBar);
% Summarize.
fe.mean = mean(fixedEffects,2);
fe.std = std(fixedEffects,0,2);
fe.ci   = [prctile(fixedEffects',p.Results.alpha/2);prctile(fixedEffects',1-p.Results.alpha/2)]';
fe.significanceMatch = -ones(nrFixedEffects,1);
isSignificant = m.Coefficients.pValue<p.Results.alpha;
fe.significanceMatch(isSignificant) = double(prod(fe.ci(isSignificant,:),2) >0); 
fe.all = fixedEffects;
re.mean = mean(randomEffects,2);
re.std = std(randomEffects,0,2);
re.ci   = [prctile(randomEffects',p.Results.alpha/2);prctile(randomEffects',1-p.Results.alpha/2)]';
re.all = randomEffects;



%% Graphical output
% Plot a histogram of each of the fixed effects plus the log likelihood
FE = m.fixedEffects;
if p.Results.graph
    clf;    
    matchLabels = {'n.s.','no-match','match'};
    tiledlayout("flow");
    for f=1:nrFixedEffects
        % Show a histogram for each fe
        ax(f) = nexttile;
        histogram(fixedEffects(f,:),'Normalization','probability');
        hold on
        plot(FE(f)*[1 1],ylim,'k','LineWidth',2);
        plot([0 0],ylim,'k','LineWidth',0.5)
        match = matchLabels{fe.significanceMatch(f)+2};
        title (sprintf('%s (%s): %.3G CI [%.3G %.3G]',m.CoefficientNames{f},match,fe.mean(f),fe.ci(f,1),fe.ci(f,2)) ,"Interpreter","none");
        xlabel 'Coefficient'
        ylabel 'Probability'
        xlim(max(abs(xlim))*[-1 1])
    end
    linkaxes(ax,'xy');
    ax(nrFixedEffects+1) = nexttile;ax(nrFixedEffects+1);
    histogram(loglike,'Normalization','probability')
    hold on
    plot(m.ModelCriterion.LogLikelihood*[1 1],ylim,'k','LineWidth',2);    
    title (sprintf('%s: %.3G CI [%.3G %.3G]','Log Likelihood:',mean(loglike,"omitnan"),prctile(loglike,2.5),prctile(loglike,97.5)) ,"Interpreter","none");
    xlabel 'Log Likehood'
    ylabel 'Probability'

    if strcmpi(mode,'FITPLUSNOISE')
        % Show the residuals and how they are fit by the kernel density
        ax(nrFixedEffects+2) =nexttile;
        maxResidual = prctile(abs(m.residuals),97.5);       
        nrBins = round(numel(m.residuals)/10);
        x= linspace(-maxResidual,maxResidual,nrBins);
        hold on
        R= m.residuals;        
        % Match histogram and density colors. Histogram handle does not
        % conatin the color that was used (only 'auto')
        axColors = ax(nrFixedEffects+2).ColorOrder;
        nrColors = size(axColors,1);
        for b=1:nrHeteroBins
            thisGroup = responseGroupingIx==b;
            h = histogram(R(thisGroup),x,'Normalization','Probability');       
            thisColor = axColors(mod(b-1,nrColors)+1,:);
            h.FaceColor = thisColor;
            thisPdf =pdf(noiseDistribution{b},x);
            plot(x,thisPdf./sum(thisPdf),'LineWidth',2,'color',thisColor) 
        end
        xlim(maxResidual*[-1 1])
        xlabel 'Residual'
        ylabel 'Probability'
        legend('Residuals','Kernel Density Estimate')
    end
end

end

